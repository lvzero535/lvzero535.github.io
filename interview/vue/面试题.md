# Vue面试题

## 1. Vue中的双向绑定

双向绑定是模板中数据和实例中数据的双向绑定，当数据发生变化时，模板会自动更新，当模板发生变化时，数据也会自动更新。

模板中使用双向绑定的语法是 `v-model`，实际是语法糖，等价于 `:value` 和 `@input` 事件的组合。当模板数据更新时，会触发 `@input` 事件，更新实例数据。

实例数据也就是响应式数据，当实例数据发生变化时，会触发视图的响应式更新。

注意：

- 双向绑定只适用于表单元素（如输入框、选择框等），不适用于普通的DOM元素。
- 对于不同表单元素，双向绑定被不同的属性绑定。
  - 输入框、文本域使用 `v-model` 绑定 `value` 属性。
  - 选择框使用 `v-model` 绑定 `selected` 属性。
  - 复选框使用 `v-model` 绑定 `checked` 属性。
- Vue2 中使用 `v-model` 绑定的属性是 `value`，而 Vue3 中使用 `v-model` 绑定的属性是 `modelValue`。
- v-model可以在组件中使用，Vue2只能使用一个 `v-model`，而 Vue3 中可以使用多个 `v-model`。
- Vue2 中想要使用多个 `v-model`，可以使用 `:value2.sync`。

## 2. vue中key的作用

### 什么是key

在vue中，key是虚拟DOM节点（VNode）的唯一标识。

当Vue更新视图时，会进行虚拟DOM diff算法。它会拿旧的VNode树与新的VNode树进行对比，找出哪些节点可以复用，哪些节点需要被创建或删除。

如果两个节点的key 和 节点的类型 都相同，那么Vue会认为这两个节点是相同的节点，直接复用；否则，Vue会认为这两个节点是不同的节点，销毁旧节点，创建新节点。

### 不设置key

默认是不设置key的，Vue会尽可能地复用相同类型的节点。这样是高效的，但只适用于列表输出的结果不依赖子组件状态或临时DOM状态（例如表单输入值）。

否则可能会导致错误的节点被复用，如：
在列表中插入或删除元素时，Vue 可能错误地复用相邻节点的 DOM，导致状态错乱（如输入框内容错位）。

### 设置key

根据 key 的变化顺序来重新排列元素，并且将始终移除/销毁 key 已经不存在的元素。

同一个父元素下的子元素，key 必须是唯一的，不然会导致渲染异常。

官方推荐在列表渲染时，使用唯一的 key 来标识每个节点，这可以帮助 Vue 更准确地进行 DOM diff 操作，提高渲染效率。

## 3. 什么时候用ref，什么时候用reactive？

[ref和reactive的区别](https://juejin.cn/post/7554770983162871846)

ref 用于定义基本类型的响应式数据，如字符串、数字、布尔值等。
reactive 用于定义引用类型的响应式数据，如对象、数组等。

reactive不能直接赋值，只能修改对象的属性。而ref可以直接赋值。

建议：使用ref，但当只需要响应式数据对象时，不修改，可以使用reactive。

## 4. Vue3中的Compositon API的优势是？

- Vue2中所有属性都是通过 `this` 访问的，this存在指向明确问题。
- Vue2中很多未使用方法或属性依旧被打包，并且所有全局API都是在Vue对象上公开。Composition API 对tree-shaking更友好。
- 组件逻辑共享问题，Vue2中通过mixin实现，但是会有数据来源不清晰，命名冲突等问题，而Vue3中通过Composition API提取公共逻辑到单独的函数中，实现了逻辑的复用，更方便。

## 5. Vue2和Vue3的的区别？

1. Vue3更新注重模块上的拆分，在2.0中无法使用单独模块，想要使用响应式部分，需要引入完整的Vue.js，而Vue3中可以使用单独响应式模块。
2. Vue2中很多方法是挂载在Vue对象上的，导致没使用也会打包。Vue3可以通过构建工具（如Webpack）的tree-shaking功能，只打包使用到的方法。
3. Vue3允许自定义渲染器，扩展方便。
4. Vue3中使用Proxy实现响应式，是惰性的，而Vue2中使用Object.defineProperty实现响应式，是立即的循环所有属性。
5. Vue3的响应式可以支持动态添加或删除属性，而Vue2中需要通过手动操作。
6. Diff算法重写。
7. Vue3模板优化，Vue3中使用了静态提升技术，将静态节点提取出来，避免每次渲染都创建相同的节点。