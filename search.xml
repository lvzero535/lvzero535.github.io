<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XMLHttpRequest 内容详细]]></title>
    <url>%2F2020%2F03%2F22%2FXMLHttpRequest-%E5%86%85%E5%AE%B9%E8%AF%A6%E7%BB%86%2F</url>
    <content type="text"><![CDATA[简述XMLHttpRequest 对象不用刷新浏览器就可以直接和服务器交互，获取数据，加载内容等操作。相当于局部刷新内容，ajax就是基于此对象开发的。 实践new XMLHttpRequest() 返回一个对象，里面有各种属性和方法，还有事件监听器。在IE5, IE6下有兼容性，可以new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) 替换。 实例化对象，有兼容性就处理。 初始化请求open(method, url, [async=true]) ，第三个参数默认为true异步请求。 发送数据send() 如果method为get,header时可以为空，要设置请求头时在这之前设置。 监听onreadystatechange事件，当readyState变化时会触发该事件，可以在回调里判断请求是否成功readyState == 4 或 xhr.status == 200 都表示请求成功。 最后就是处理请求返回的数据了xhr.responseText。 12345678910111213141516function ajax() &#123; var xhr = null; if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else if(window.ActiveXObject) &#123; xhr = new ActiveXObject("Microsoft.XMLHTTP"); &#125; xhr.open(method, url, async = true); xhr.setRequestHeader('auth', 'token'); xhr.send(); xhr.onreadystatechange = function() &#123; if(xhr.readyState === 4 || xhr.status === 200) &#123; console.log(xhr.responseText); &#125; &#125;&#125; 属性或方法readyStatereadyState 代表一个请求码，不同时期有不同值，当这个值变时会触发onreadystatechange 监听的回调函数。一共有5 值，如下： 状态 值 描述 0 UNSENT 代理（实例化）被创建，但尚未调用open()方法。 1 OPENED open()方法已被调用。 2 HEADERS_RECEIVED send()方法已被调用，并且头部和状态已经可以获得。 3 LOADING 下载中；responseText属性已经包含部分数据。也就是说onprogress 事件在触发的过程中。 4 DONE 下载操作完成，可以这个为准处理成功的数据 onreadystatechange当readyState 属性改变时，触发该监听的回调事件 responseType手动设置服务器响应数据的类型，默认为 text 。当设置为空字符串时也是默认text。 注意： 设值时和设header一样，在open()和send() 之间才可以。 设置的类型和服务器响应的数据类型不兼容时，返回的数据变成null。比如说：响应数据是text/html时，设置为json 时获取到的就是null 值 描述 “ ” 或 text 默认类型（DOMString） arraybuffer response是一个二进制数据 ArrayBuffer blob response 是一个二进制数据 Blob document response是一个HTML Document或XML XMLDocument，取决于接收到的数据的MIME类型 json response是一个JavaScript对象。这个对象是通过JSON解析得到的 response服务器响应的数据类型，类型可以是ArrayBuffer、Blob、Document、JavaScript Object、DOMString默认值，取决于responseType 属性。 responseText只能在responseType 属性为text时获取服务器响应的值，responseType是其他值时会报错。 请求未发出或未成功时为null。 responseURL返回响应的序列化（serialized）URL，如果该 URL 为空，则返回空字符串。 statusHTTP状态码 statusText和status 状态码对应的状态本文 timeout设置请求最大的超时时间（毫秒），若超出该时间时，请求会自动结束。 ontimeout当请求超时会触发监听事件。 upload代表上传代表的对象。可以绑定事件追踪上传进度。事件和XMLHttpRequest一样 withCredentials布尔值，默认为false 。当跨域请求时，cookies，authorization headers头部受权或TLS客户端证书，服务器无法获取上述内容，因为浏览器忽略这些不会和请求一起发送到后端的，只有设置为true 时才会发送给服务器。 方法 abort如果请求已发送，立即中止请求。 getAllResponseHeaders 以字符串形式返回所有用CRLF分隔的响应头，没响应是null。 getResponseHeader(headerName) 返回指定响应头的字符串，未响应或不存在则是null 。 open(method, url, [async=true]) 初始化一个请求。 setRequestHeader(headerName, headerValue) 在open之后send之前才有效 send(data) 发送请求数据。 overrideMimeType 重写由服务器返回的mime类型 事件请求过程中会有一系列事件监听。 可以用on + type，也可以用addEventListener监听事件。 事件 描述 abort 当request请求停止时触发，如调用abort方法会触发 error 当request遭遇错误时触发 load 当request请求成功时触发 loadend 请求结束时触发，无论成功（load）还是失败（error）触发 loadstart 请求收到响应数据时触发（数据还没完全响应，和progress 同一时期触发） progress 请求接收到数据开始周期触发 timeout 在预设时间内没收到响应时触发]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>XMLHttpRequest</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript防抖]]></title>
    <url>%2F2019%2F07%2F27%2FJavaScript%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[JavaScript防抖防抖就是持续触发的事件中，最后一个事件触发时在一定时间周期后再执行这个事件。 也就是说，每次触发事件，如果这个事件还没执行，那么之前触发的事件会清除，以最后一个事件为主，等待的时间会重新开始。 当然也会分第一次是否执行。 第一版简单的实现 1234567891011// 第一版，时间戳, 默认是首次执行的function debounce(fun, wait) &#123; var timeout; return function() &#123; var context = this, args = arguments; clearTimeout(timeout); timeout = setTimeout(function() &#123; fun.apply(context, args); &#125;, wait); &#125;&#125; 第二版第三个参数是第一次是否执行。 当前immediate 为 true时，判断 first 是否第一次执行，第一次执行后，改变first的值，下次再触发就不再立即执行，最后一次执行是定时器里，要first复原，等待下次第一次执行。 result返回结果只有第一次会有效。 1234567891011121314151617function debounce(fun, wait, immediate) &#123; var timeout, fisrt, result, context, args; return function() &#123; context = this, args = arguments; if(immediate &amp;&amp; !fisrt) &#123; fisrt = true; result = fun.apply(context, args); &#125; clearTimeout(timeout); timeout = setTimeout(function() &#123; fisrt = false; fun.apply(context, args); timeout = args = context = null; &#125;, wait); return result; &#125;&#125;]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript节流]]></title>
    <url>%2F2019%2F07%2F20%2FJavaScript%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[JavaScript节流节流就是持续触发的事件，每隔一段时间，只执行一次。如鼠标移动触发的事件，如果太频繁，导致性能问题，就需要用到节流。 根据首次是否执行以及尾次是否执行，实现也是不同。使用leading和trailing分别判断首尾是否执行。 节流的实现有两种方式，一：时间戳，二：是定时器。 使用时间戳当事件触发时，取出当前的时间戳，然后减去之前的时间戳（一开始设置为0），如果大于设置的间隔时间就执行，然后更新时间戳为当前时间戳为下次使用，小于就不执行。 12345678910111213// 第一版，时间戳, 默认是首次执行的function throttle(fn, wait) &#123; var context, previous = 0; return function(...rest) &#123; context = this, now = +new Date; if(now - previous &gt; wait) &#123; fn.apply(context, rest); previous = +new Date; &#125; &#125;&#125; 使用定时器12345678910111213// 第二版，定时器, 默认是首次不执行的,尾次执行function throttle(fn, wait) &#123; var timer, context; return function(...rest) &#123; context = this; if(!timer) &#123; timer = setTimeout(function()&#123; fn.apply(context, rest); timer = null; &#125;, wait) &#125; &#125;&#125; 结合版本如果首尾都执行，可以结合这个两个版本 1234567891011121314151617181920212223242526272829303132333435function throttle(fn, wait) &#123; var timeout, context, args, previous = 0; var later = function() &#123; previous = +new Date; timeout = null; fn.apply(context, args) &#125; return function() &#123; var now = +new Date; // 下次触发剩余时间， // previous 首次是0， remaining是负数，所以首次必然会执行 // 执行过一次后，previous是上次执行的时间 // 再次触发时，就是现在的时间和上次执行时间的差值和时间周期的差值就是下次执行剩余的时间 var remaining = wait - (now - previous); context = this; args = arguments; // 或者你修改了系统时间，当前你修改系统时间时， // 如果多次触发事件时，remaning一样会减少，当前小于等于0时，说明等待时间周期到了，要执行 // remaining &gt; wait 的情况就是 now 小于 previous的情况，这是修改了系统时间 if( remaining &lt;=0 || remaining &gt; wait) &#123; if(timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; fn.apply(context, args); // 在有剩余时间触发后，还后保证之后再执行一次 &#125; else if (!timeout) &#123; timeout = setTimeout(later, remaining); &#125; &#125;&#125; 网上还有一种方法这样写，比较简洁，就是用第二版 1234567891011121314function throttle(fn, wait) &#123; var timer, context; return function(...rest) &#123; context = this; if(!timer) &#123; timer = setTimeout(function()&#123; fn.apply(context, rest); timer = null; &#125;, wait); // 立即执行 fn.apply(context, rest); &#125; &#125;&#125; Underscore版本12345678910111213141516171819202122232425262728293031323334353637// 像underscore 一样的版本// options.leading : false 首次不执行// options.trailing : false 尾次不执行function throttle(fn, wait, options) &#123; var context, args, result, timer, previous = 0; // 最后一次执行的函数 if (!options) options = &#123;&#125;; var later = function () &#123; // 执行到这里，说明不是第一次触发事件了，所以这里如果下一次触发的首次不执行 previous = options.leading === false ? 0 : new Date().getTime(); timer = null; result = fn.apply(context, args); // 垃圾回收 if(!timer) context = args = null; &#125; return function() &#123; var now = +new Date; // 第一次触发，且首次不执行的 if(!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if(remaining &lt;=0 || remaining &gt; wait) &#123; if(timer) &#123; clearTimeout(timer); timer = null; &#125; previous = now; result = fn.apply(context, args); if(!timer) context = args = null; &#125; else if(!timer &amp;&amp; options.trailing !== false) &#123; timer = setTimeout(later, remaining); &#125; return result; &#125;&#125; 注意： 1、underscore 的版本里，如果leading和traiding同时设置为false ,再再下次触发时由于没有timer且，上次执行时有previous = now，所以这时remaining为负的，所以会相当于立即执行，就相leading:false` 时冲突了，相当于bug吧。 2、return result在trailing !== false 时，最后一次没用，如果 fn是异步的也没用。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa和typescript后端实现Demo]]></title>
    <url>%2F2019%2F07%2F10%2Fkoa%E5%92%8Ctypescript%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0Demo%2F</url>
    <content type="text"><![CDATA[前言对TypeScript 神往已久，看过Angular 4+ 写过小Demo，没用它写过后端，一直想通过TypeScript写一个Demo后端，听说Nestjs 和Java 的Spring 有的一拼，但没上手，只能用Koa 来凑，后续用Nestjs补上。这只是一个后端，没有前端页面。具体代码:Github地址 安装依赖1234npm intall koa koa-bodyparser koa-routernpm intall typeorm reflect-metadata mysql2npm install @types/koa @types/koa-bodyparser @types/koa-router -Dnpm install nodemon ts-node typescript -D 依赖中值得注意的是： nodemon 改动代码后node启动的服务器不会自动刷新，修改后的代码就不生效，要重启才生效。这个工具就是实时监控代码改变后自动重启服务器的。详情看： https://github.com/remy/nodemon ts-node`typescript`代码正常来说要转译才可以运行，但是这个工具提供了运行环境。 reflect-metadata typeorm 需要ES7 装饰器，需要这个依赖。由于typescript的装饰器是实验功能，所以在tsconfig.json 时要配置，不然报错。 12"emitDecoratorMetadata": true,"experimentalDecorators": true 代码实现第一步，连接数据库，启动服务监听端口，连接是全局的，详情看 https://github.com/typeorm/typeorm 123456789101112131415161718192021222324252627282930313233import * as Koa from 'koa';import * as Router from 'koa-router';import * as bodyParser from 'koa-bodyparser';import &#123; createConnection &#125; from 'typeorm';import User from './entities/user';import routes from './routes';createConnection(&#123; type: "mysql", host: "localhost", port: 3306, username: "username", password: "password", database: "database", entities: [ User // 实体对象 ], synchronize: true, logging: false&#125;).then(connection =&gt; &#123; const app = new Koa(); app.use(bodyParser()); const router = new Router(); router.use(routes.routes()); app.use(router.routes()).use(router.allowedMethods()); app.listen(8888, () =&gt; &#123; console.log('starting -------') &#125;)&#125;).catch(err =&gt; console.log('typeorm connect failed,', err)) 第二步是，定义表实体，装饰器详情看typeorm文档 123456789101112131415161718192021222324252627282930313233import &#123; Entity, PrimaryGeneratedColumn, Column &#125; from 'typeorm';@Entity()export default class User &#123; @PrimaryGeneratedColumn('uuid') id: string; @Column(&#123; length: 20 &#125;) username: string; @Column(&#123; length: 40 &#125;) password: string; @Column(&#123; length: 11 &#125;) phone: string; @Column(&#123; length: 40 &#125;) email: string; @Column(&#123; length: 1 &#125;) gender: string;&#125; 第三步是写操作数据库的实现 12345678910111213141516171819202122232425// service 直接操作实体对象就可以，像java的hibernateimport &#123; Repository, getRepository &#125; from "typeorm";import User from "../entities/user";export default class UserService &#123; private static repositoryUser(): Repository&lt;User&gt; &#123; return getRepository(User); &#125; public static async getUsers() &#123; return this.repositoryUser().find(); &#125; public static async getUserById(id: string) &#123; return this.repositoryUser().findOne(id); &#125; public static async addAndUpdateUser(user: User) &#123; return this.repositoryUser().save(user); &#125; public static async deleteUser(user: User) &#123; return this.repositoryUser().remove(user); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 控制器，路由过来的请求处理import &#123; BaseContext &#125; from "koa";import UserService from "./service";import User from "../entities/user";export default class UserController &#123; public static async getUsers(ctx: BaseContext) &#123; const users: User[] = await UserService.getUsers() ctx.status = 200; ctx.body = users; &#125; public static async getUserById(ctx: BaseContext) &#123; ctx.status = 200; ctx.body = await UserService.getUserById(ctx.params.id); &#125; public static async addUser(ctx: BaseContext) &#123; const user: User = ctx.request.body; ctx.status = 200; ctx.body = await UserService.addAndUpdateUser(user); &#125; public static async updateUser(ctx: BaseContext) &#123; const findUser = await UserService.getUserById(ctx.params.id); if(!findUser) &#123; ctx.status = 400; ctx.body = 'user is not exists!' &#125; else &#123; ctx.status = 200; ctx.body = await UserService.addAndUpdateUser(Object.assign(findUser, ctx.request.body)); &#125; &#125; public static async deleteUser(ctx: BaseContext) &#123; const findUser = await UserService.getUserById(ctx.params.id); if(!findUser) &#123; ctx.status = 400; ctx.body = 'user is not exists!' &#125; else &#123; ctx.status = 204; await UserService.deleteUser(findUser); &#125; &#125;&#125; 123456789101112// 路由定义，符合REST Ful规范import * as Router from 'koa-router';import controller from './controller';const router = new Router();router.get('/users', controller.getUsers);router.get('/users/:id', controller.getUserById);router.post('/users', controller.addUser);router.put('/users/:id', controller.updateUser);router.delete('/users/:id', controller.deleteUser);export default router; 实践启动 npm start 1234[nodemon] 1.19.1[nodemon] to restart at any time, enter `rs`[nodemon] watching: f:\ProcedureDocument\CodeHome\js\node\koa-ts\server/**/*[nodemon] starting `ts-node ./server/index.ts` 最后用Postman测试各接口没问题。 这是简单的实现，什么都没有，只有接口，没有权限控制，没有测试，没有前端，当然这是为nestjs铺垫，当然后面有时间会补齐。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Koa</tag>
        <tag>typescript</tag>
        <tag>mysql</tag>
        <tag>node</tag>
        <tag>typeorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS执行过程]]></title>
    <url>%2F2019%2F04%2F15%2FJS%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[JavaScript运行过程加载每个script标签的代码是独立的，但是共享全局作用域。如果有多个script标签，其中一个发生并抛出错误时并不会影响其他script标签代码运行。 &lt;script src=&#39;&#39;&gt; 立即加载执行，阻塞HTML解析渲染。 &lt;script defer src=&#39;&#39;&gt; 加载和HTML解析并行，但要等HTML解析完成才执行，且是按加载顺序执行，先于 DOMContentLoaded 事件执行。 &lt;script async src=&#39;&#39;&gt;加载和HTML解析并行，但加载完成立马执行，阻塞HTML解析渲染。执行是无序的。一定在load事件前面执行，但DOMContentLoaded 不确定。 作用域加载完代码后，开始运行，这个运行根据个人理解是有两个阶段的，这两个阶段过程就是所谓的VO(变量对象), AO(活动对象) 。 第一个阶段这是代码预编译阶段，主要是词法、语法分析，确定作用域（也就执行上下文）。 注意:作用域是在这个时候，而不是在执行的时候确定的。 12345678910var a = 2;function bar() &#123; console.log(a); // 2，作用域在第一阶段已确定&#125;function foo() &#123; var a = 4; console.log(a); // 4 bar();&#125;foo(); 首先是创建全局的执行上下文，也就是全局作用域，声明变量。这个时候只是声明变量而已，还没开始赋值，这个声明而没有赋值就说的是变量提升，但是函数的提升优先级比变量高。这些变量包含基本类型，对象，函数等，声明变量时，这些变量的变量名会作为作用域的属性名。作用域包含变量属性名的也叫VO 变量对象 。如果声明变量时类型是Function 的，会再创建一个作用域，这个作用域里的代码分析和全局作用域的一样，只不过这个function的作用域是挂在全局作用域上的，如果函数里还有函数过程一样，内嵌函数作用域挂外层函数的作用域上，这就形成了作用域链。 在JavaScript 里作用域只有全局作用域和局部作用域（函数作用域），eval和with 也可以创建作用域，但不常用，最好也不要用。ES6之前是没有块级作用域的，但在ES6的时候加了let const这两个后就有了块级作用域的说法了，且用这两个声明的变量不存在变量提升，详情请看ES6语法 12345678910111213141516a = 2; // 执行阶段才赋值var a; // 编译阶段就声明了console.log(a); // 2;// ============================================// 函数的优先级更高console.log(foo); // foo Functionconsole.log(foo());// 3var foo = 2;console.log(foo); // 2console.log(foo()); // 报错：Uncaught TypeError: foo is not a function function foo() &#123; return 3;&#125;console.log(foo); // 2console.log(foo()); //报错：Uncaught TypeError: foo is not a function 第二个阶段第一阶段完成后开始执行代码。 首先把全局作用域推入栈中，开始对变量赋值然后执行代码，也就是说变量值的确定是在执行阶段确定的，这个赋值就是所谓的（VO =&gt; AO）的转变，这是作用域变量对象到活动对象的转变。执行过程遇到作用域会继续把它推入栈中，形成一个作用域栈队列。栈的特点是先进后出，当最上面的作用域对应的函数执行完成，会移出栈的队列，直到最底的全局作用域移除，整个栈队列为空，这时程序执行完成。 注意：正常来说，作用域移出栈后，作用域里所有变量所分配的内存会被当垃圾回收，然后作用域被销毁。然而这里有一种情况就是，这个作用域移出栈外是临时的，因为这个作用域内还有变量被子作用域的变量所引用，不能被垃圾回收器回收，当子作用域被激活时，移出栈外的父作用域和子作用域同时又会被推入栈中。这就是说闭包的情况。 123456789function foo() &#123; var a = 2; // 被 bar 的作用域引用，就是foo的子作用域（好像是没有子作用域的说法） function bar() &#123; return a; &#125; return bar;&#125;var baz = foo();console.log(baz()) // 2; 垃圾回收器上面说到作用域的变量被垃圾回收器回收，那变量什么时候会被回收呢？ JavaScript在定义变量时会自动分配内存，当变量不再使用时，会被回收，但是怎么样判断变量不再使用呢？ JavaScript引擎有两种回收算法。 引用计数算法定义变量后，可能有其他变量引用，也可能没有。当有其他变量引用时，该变量被引用次数为1次引用，被引用多少次就计数多少次，当释放引用后就减少引用次数，当引用为零时被回收。 这个算法有个限制那就是循环引用 时，不会被回收，这就有可能出现内存益出的情况。 如IE6，8使用计数方式对DOM对象回收时，常造成循环引用发生内存泄漏。 123456var div;window.onload = function() &#123; div = document.getElementById('idtest'); div.dataEle = div; div.lotsOfData = new Array(10000).join("*");&#125; 标记清除法引用计数算法的限制，标记清除法则不存在这个问题，现代所有浏览器都使用了该算法作为垃圾回收算法。 这个算法就是定期从全局作用域开始查找所引用的对象，还有对象引用的对象。垃圾回收器将找到所有可以获得的对象和不可获取的对象。不可获得的对象被当垃圾回收。这就像一棵树，从根开始向上找，能找到的都在树上，找不到的都在树下，树下的就是垃圾。 这里也有一个限制就是无法从根上找到的对象都被回收，这也是算法的核心。当然这种可用的对象应用场景很少，所以不太用关心。 事件循环JS引擎是单线程的，不存在并发编程，但JS存在异步编程，通过事件循环实现的。 JS代码在执行过程中会触发各种各样的事件，如异步的ajax回调 setTimeout，setInternal的定时事件 还浏览器触发的同步事件如onclick 等，同步事件还好，触发就立马执行了，但是异步的事件是什么时候触发的呢？ 这里有两个概念macrotask和 microtask： macrotask又称宏任务或者主任务，就是主代码块和其他产生的异步事件。 microtash又称微任务，Promise，Process.nextTick。 1、首先主代码执行，执行过程产生的异步事件推到事件队列中，微任务推到微任务队列中。 2、主代码执行完成后，判断是否有微任务，有就执行，没有就渲染浏览器。 3、渲染完浏览器后下一个宏任务开始（先判断是否有事件，先执行事件）。 123456789101112console.log('start');setTimeout(() =&gt; &#123; console.log('setTimeout');&#125;, 3000);Promise.resolve('Promise').then((val) =&gt; &#123; console.log('Promise')&#125;)console.log('end');// start// end// Promise// setTimeout 事件循环如下图： 最后这里的总结只是JS执行过程的简化而已，实际上比这里说的复杂的多，由于初始涉及不是很深入，如有错误，请各位纠正。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染原理]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浏览器原理浏览器是属于多进程的。 1、主进程，主控，协调； 2、第三方进程，一个插件对应一个进程； 3、GPU进程，3D绘制； 4、浏览器渲染进程，每个tab对应一个渲染进程，互不影响。 ​ 主要是页面渲染、脚本执行、事件处理等。 事件循环主执行栈—&gt; 微任务—&gt;渲染 —&gt; 主执行栈 从输入 RUL 到页面加载完成发生了什么事 DNS解析 TCP连接 发送HTTP请求 浏览器对同一域名的并发请求是有数量限制的，不同浏览器限制数量不一样。 每个请求都会主动添加cookie到请求头。 这个数量限制主要考虑到：端口数量、线程切换开销，还有服务器压力等。 和并发数有关技术： domain hash 增加并发数量。 cookie free CDN，减少cookie传输带来的消耗。 css sprites 多张图片合成 一张，通过background的定位引用同一张图片。 js/css combine js/css模块化来减少重绘重排。 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 渲染引擎 IE (Trident) -ms- Safari(Webkit) -webkit- Chrome;Opera(Blink) 基于webkit Chrome -webkit- Opera -o- Firefox(Gecko) -moz- 通过autoprefixer工具添加前缀，不要手动添加。 引擎包括：HTML解析器，CSS解析器，布局layout模块，javascript引擎，绘图模块等。 渲染进程 渲染进程是浏览器的内核，也是核心，主要对面进行解析，渲染，展现；该进程是多线程的。 1、GUI渲染线程 解析HTML，CSS，构建DOM树， render树，布局和绘制等。 重绘、重排进会触发执行该线程。 注意，GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时，GUI会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 2、JS引擎线程 负责解析、运行JavaScript代码。 一个渲染进程只有一个JS线程，这就是说的单线程。 如果是多线程的，对DOM的操作会造成混乱，处理问题更新复杂。 GUI渲染线程与JS引擎线程是互斥的 JS的执行会阻塞页面的渲染。 3、事件触发线程 控制事件循环。 Web API 时将对应任务添加到事件线程中，如setTimeout，ajax 。 当对应事件符合触发条件时，事件线程会事件添加到待处理队列的队尾，等待JS引擎处理。 事件处理以后总结。 4、定时触发器线程 setInterval与setTimeout所在线程。 浏览器定时计数器不是由JS引擎计数的。 由于JS引擎是单线程的，如果处于阻塞状态，会影响计时准确。 计时完成会触发该线程执行任务，如添加事件到事件队列中。 5、异步http请求线程 XMLHttpRequest在连接后通过浏览器新开一个线程请求。 检测到状态变更时，如果有回调函数，该线程就产生状态变更事件，把事件放到事件队列中。 6、问题 细心的看官可能发现问题了。这里有一个事件队列，该队列是由JS引擎线程维护，还有一个事件触发线程。那么问题来了，把事件添加事件队列中的是事件线程还是其他生成该事件的线程？或者是部分事件由事件线程添加？ 如果有哪位了解的可否给笔者详情说道说道？ 渲染过程1、获取页面资源。 2、解析HTML生成DOM树。 3、解析CSS生成CSSOM树。 4、将DOM树和CSSOM树结合生成渲染树。 ​ 生成渲染树的过程应该是对各个元素的位置大小计算，还有图层的划分，即是布局。 5、绘制、合成这些图层然后展示。 webkit渲染过程 Gecko渲染过程 由图可知：CSS的加载不会阻塞DOM树的解析，但会阻塞渲染。 CSS会阻塞JS吗123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- &lt;link rel="stylesheet" href="style.css" /&gt; --&gt; &lt;style&gt; div &#123; color: red; &#125; &lt;/style&gt; &lt;script&gt; console.log('before css'); var st = Date.now(); &lt;/script&gt; &lt;script src=""&gt;&lt;/script&gt; &lt;link href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt; test &lt;/div&gt; &lt;script&gt; console.log('after css'); console.log(Date.now() - st); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 把浏览器下载速度调用低可以看出，CSS加载会阻塞后面的JS执行。 由于JS会修改html和css，因此浏览器会维持html中的js和css的执行顺序。 DOMContentLoaded onLoad事件就是所有资源都加载完成时触发，而DOMContentLoaded在DOM解析完成后触发。onLoad事件执行在DOMContentLoaded后触发。 ​ 遇到JS代码时，等到执行完成JS代码时才会继续解析HTML；在执行JS代码的这个过程，浏览器还是会预解析HTML的，但和主线程解析不同，预解析只会做准备工作，把解析好的内容放到内存中，如果中间有资源要加载就会去加载，但不会渲染。 CSS图层每个图层，渲染，计算位置大小都相互不影响。这个图层和PS里的图层差不多。如果有出现gif图的，这个图所在的图层会一直处于重绘状态。这时可以给它单独开一个图层减少开销。 生成图层条件 拥有具有3D变换的CSS属性。 &lt;video&gt; &lt;canvas&gt; 节点 CSS3动画节点 拥有CSS加速属性的元素（will-change:transform） 元素有一个z-index 较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染） 其他 重绘（repaint）重绘是一个元素外观的改变所触发的浏览器行为，如outline，背景颜色等属性。重绘不会重新布局，所以并不一定伴随重排。 注意：如果图层中的某个元素重绘，整个图层都需要重绘。 重排（reflow 回流）渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。 注意：重排必然导致重绘。 最后了解了浏览器渲染原理后，可以根据这个对前端知识的补充，很快就会形成一个知识体系，不然总是零零碎碎的知识很难有大体上的把握。比如要优化前端性能从哪里开始，首先人框架上解决，如CDN，图片合成，减少HTTP请求。还有代码上的优化，如CSS的图层渲染或减少重绘重排，JS的尾调用优化等。 下遍继续总结下JS引擎的运行代码的过程。 这遍文章查看了好多资源总结的，如有错误请指出。 部分参考https://juejin.im/post/5b88ddca6fb9a019c7717096 https://segmentfault.com/a/1190000012925872 https://www.zhihu.com/question/20474326]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS尾调用优化]]></title>
    <url>%2F2019%2F04%2F07%2FJS%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[尾调用优化一个出现在另一个函数“结尾”处的函数调用，这个调用结束后函数执行完成。 调用一个新的函数需要额外的一块预留内存来管理调用栈，称为栈帧。 如果有一个函数在另一个函数尾部调用时，引擎能够意识后者函数已经完成了，那么前者不需要创建一个新的栈帧，重复使用老的栈帧，这样速度快，也更节省内存。 这样在深度递归调用时可以使用尾调用优化，避免内存益出。 12345678910function foo(x) &#123; return x;&#125;function bar(y) &#123; return foo( y + 1 ); // 尾调用&#125;function baz() &#123; return 1 + bar( 40 ); //bar函数完成后还要执行加法， 非尾调用&#125;baz(); // 42 12345678function factorial(n) &#123; function fact(n, res) &#123; if(n&lt;2) return res; return fact(n-1, n*res); &#125; return fact(n, 1)&#125;factorial(5) // 120 尾调用优化递归，]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router路由]]></title>
    <url>%2F2019%2F03%2F15%2FVue-router%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[Vue-router动态路由 动态路由是通过在路由中添加参数来实例渲染不同的数据，如果一个用户组件渲染不同用户。 /user/:id —&gt; /user/foo:/user/bar /user/:id/posts/:postid —&gt; /user/foo:/user/bar 这个参数可以在路由对象中获取。如组件方法中：this.$route.params.id 注意: 使用路由参数时，由于两个路由渲染的是同一个组件，为了高效，组件实例会复用。不过这样会导致生命周期钩子函数不会调用。也不会触发进入、离开的导航守卫。 组件中的路由对象可以在组件中通过 this.$route调用路由对象，this.$router调用路由实例。 在组件中获取路由参数或路由查询参数时： this.$route.params 是一个对象，里面包含所有路由参数。 this.$route.query 是一个对象，里面包含所有路由查询参数。 使用 props 将组件和路由解耦： 无需在组件内调用$route，在配置路由时加上props属性 123456789&#123; path: '/user', component: User, props: true&#125;// props: Boolean | Object | Function// props: true, // 这时 route.params 将会设置为组件属性// props: Object, // 整个对象原样设置为组件属性// props: (route) =&gt; (&#123;name: route.query.name&#125;), // 函数返回的内容设置为组件属性 守卫导航123456789101112131415161718192021222324252627282930313233343536373839function callback(to, from, next) &#123; // to: Route：即将要进入的目标路由对象。 // from: Route：当前导航正要离开的路由对象。 // next: Function，相当于中间件的next方法或是promise的resolve。 // next()：进入下一个守卫的函数。如果不调用该函数，当前导航一直在等待中。 // next(false): 中断当前的导航，URL地址重置到 from 路由。 // next('route路由对象')：不跳到 to 目标路由，跳到自定义路由上。这可以判断该用户在此路由是否有权限，没有就跳到指定路由页面。 // next(error)：导航中止，如果router.onError(callback)函数有注册，则error传参给callback；没注册则报出异常。&#125;function afterCallback(to, from) &#123; // to: Route：即将要进入的目标路由对象。 // from: Route：当前导航正要离开的路由对象。&#125;beforeEach(callback) // 全局前置守卫，所有路由进入前都会执行。afterEach(afterCallback) // 全局后置钩子，所有路由导航结束后都会执行。beforeResolve(callback) // 解析守卫，在路由独享守卫（beforeEnter），和组件内守卫（beforeRouteEnter）之后执行。beforeEnter(callback)// 路由独享守卫，在全局前置守卫(beforeEach)之后执行。beforeRouteEnter(callback)// 组件内守卫，在路由独享守卫之后执行。// 在渲染该组件的对应路由被confirm前调用// 不~能~获取组件实例 `this`// 因为当守卫执行前，组件实例还没有被创建。// 可以在next参数回调函数的参数中传入实例对象// next((vm) =&gt; &#123;vm.props&#125;) callback 回调函数在DOM更新后执行也就是 mounted之后执行。beforeRouteUpdate(callback)// 组件内守卫，第一次进入该路由时不会触发，只有在当前路由中，改变该路由时才会触发// 如 对于一个带有动态参数路径/user/:id，在 /user/1和/user/2之间跳转时才会触发。// 由于渲染同一个组件user ，会复用。// 可以访问组件实例 this， next 不支持传递回调beforeRouteLeave(callback) // 组件内守卫，离开该路由时触发，可以访问 实例this。也不支持传递回调 所以路由守卫有两种执行顺序 正常路由: ​ beforeEach(全局前置守卫) ​ beforeEnter(路由独享守卫) ​ beforeRouteEnter(组件内守卫) ​ beforeResolve(解析守卫) ​ afterEach(全局后置钩子) 【没有： beforeRouteUpdate(组件内守卫)，beforeRouteLeave(组件内守卫)】 路由复用: ​ beforeEach(全局前置守卫) ​ beforeRouteUpdate(组件内守卫) ​ beforeResolve(解析守卫) ​ afterEach(全局后置钩子) 【没有： beforeEnter(路由独享守卫) ，beforeRouteEnter(组件内守卫)， beforeRouteLeave(组件内守卫)】 注意 ： 1、以上的执行顺序是所有守卫里 next() 函数前执行的顺序。 2、next函数后的内容是反过来执行，整个路由守卫执行过程就是一个递归调用栈。 3、组件所有生命周期的钩子在守卫之后执行。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex-box布局]]></title>
    <url>%2F2019%2F03%2F03%2Fflex-box%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[[转载]Flex-box 布局 flex 即是“弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为flex布局 注意： 设备Flex布局以后，子元素的float ,clear,和vertical-align属性将失效 1234.box &#123; display: flex; // 块级元素 display: inline-flex; //行内元素&#125; 基本概念 采用Flex布局元素，称为Flex容器，它的所有子元素自动成为容器成员，称为Flex 项目，简称项目。 容器默认存在两根轴，水平的主轴（main axis）和垂直的交叉轴（cross axis）。 默认来说：main从左边开始 main start到右边main end；cross从上开始 cross start到下cross end。 容器的属性flex-direction 决定项目在主轴上的排序方向。 有四个值如下： row(默认值)：主轴为水平方向，起点从左端开始排序。 row-reverse：主轴为水平方向，起点从右端开始排序。 column：主轴为垂直方向，起点从上沿开始排序。 column-reverse：主轴为垂直方向，起点从下沿开始排序。 flex-wrap 默认情况下，项目都排在一条线（轴线）上。 有三个值： nowrap(默认值)：不换行。 wrap： 换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flow flex-flow属性是flex-direction和flex-wrap属性的简写，默认值为 row nowrap justify-content 定义了项目在水平方向上的对齐方式。 有五个值，假设为水平方向为主轴： flex-start（默认值）：左边对齐。 Flex-end：右边对齐。 center：剧中对齐。 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以项目之间的间隔比项目与边框的间隔大一倍。 align-items 定义项目在cross axis上如何对齐。 有五个值如下。cross方向从上到下。 flex-start：项目的上对齐。 flex-end：项目的下对齐。 center：cross 轴的中点对齐。 baseline：项目的第一行文字基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。align-centent 定义 了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 有六个值： flex-start：和alin-items的值一样上对齐。 flex-end：和alin-items的值一样下对齐。 center：和alin-items的值一样中心对齐。 space-between：cross的两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔与边框的间隔大一倍。 stretch（默认值）：轴线占满整个cross axis。项目属性 order 定义项目的排序顺序。数值越小，排列越靠前，默认为0。 flex-grow 定义项目的放大比例，默认为0，即如果在剩余空间，也不放大。 如果值为1，项目放大且等分剩余空间。 如果一个项目值为2，其他项目都为1，前者占据的剩余空间比其他项多一倍。 flex-shrink 定义了项目缩小比例，默认为1，如果空间不足，该项目将缩小。 所有项目的该属性都为默认值1时，当空间不足时，都将等比例缩小。 如果一项目值为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis默认值为auto，如果轴上空间够大的话。设置的值和width或height一样，有固定的空间。 flex flex是flex-grow, flex-shrink 和flex-basis的简写，默认值是 0 1 auto。后两个值是可选的。 该属性有两个快捷值： auto: 1 1 auto。 none: 0 0 auto。 align-self 该属性允许单个项目有与他项目不同的对齐方式，可覆盖align-items属性值，默认auto，表示继承父元素的align-items。如果没有父元素等同于stretch。 该属性有6个值，除了auto，其他与align-item一致。 转载：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 转载代码：http://static.vgee.cn/static/index.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS水平垂直剧中]]></title>
    <url>%2F2019%2F02%2F24%2FCSS%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%89%A7%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[绝对定位 + margin:auto12345678910111213141516171819202122232425262728&lt;style&gt; .wrp &#123; background-color: #b9b9b9; width: 240px; height: 160px; &#125; .box &#123; color: white; background-color: #3e8e41; width: 200px; height: 120px; overflow: auto; &#125; .wrp1 &#123; position: relative; &#125; .box1 &#123; margin: auto; position:absolute; left: 0; right: 0; bottom: 0; top: 0; &#125;&lt;/style&gt;&lt;div class="wrp wrp1"&gt; &lt;div class="box box1"&gt; &lt;h3&gt;完全居中层1：&lt;/h3&gt; &lt;h3&gt;开发工具 【 WeX5 】： 高性能轻架构、开源免费、跨端、可视化&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; 剧中元素box1不需要计算大小。 效果图 绝对定位+margin反向偏移123456789101112131415161718&lt;style&gt;.wrp2 &#123; position: relative; &#125; .box2 &#123; position:absolute; left: 50%; top: 50%; margin-left: -100px; margin-top: -60px; &#125;&lt;/style&gt;&lt;div class="wrp wrp2"&gt; &lt;div class="box box2"&gt; &lt;h3&gt;完全居中层2：&lt;/h3&gt; &lt;h3&gt;开发工具 【 WeX5 】： 高性能轻架构、开源免费、跨端、可视化&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; 剧中元素需要确认大小，margin 上 、左是元素对应高、宽一半，反向。 绝对定位+transform反向偏移1234567891011121314151617&lt;style&gt;.wrp3 &#123; position: relative; &#125; .box3 &#123; position:absolute; left: 50%; top: 50%; transform: translate(-50%, -50%) // 和方案2一样 &#125;&lt;/style&gt;&lt;div class="wrp wrp3"&gt; &lt;div class="box box3"&gt; &lt;h3&gt;完全居中层3：&lt;/h3&gt; &lt;h3&gt;开发工具 【 WeX5 】： 高性能轻架构、开源免费、跨端、可视化&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; display: table12345678910111213141516171819&lt;style&gt; .wrp4 &#123; display: table; &#125; .sub4 &#123; display: table-cell; vertical-align: middle &#125; .box4 &#123; margin: auto; &#125;&lt;/style&gt; &lt;div class="wrp wrp4"&gt; &lt;div class="sub4"&gt; &lt;div class="box box4"&gt; &lt;h3&gt;完全居中层4：&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; display: inline-block12345678910111213141516171819&lt;style&gt; .box5 &#123; display: inline-block; vertical-align: middle; width: auto; height: auto; &#125; .wrp5::after &#123; content: ''; display: inline-block; vertical-align: middle; height: 100%; &#125;&lt;/style&gt; &lt;div class="wrp wrp5"&gt; &lt;div class="box box5"&gt; &lt;h3&gt;完全居中层5：&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; display: flex-box12345678910111213141516&lt;style&gt; .wrp6 &#123; display: flex; justify-content: center; align-items: center; &#125; .box6 &#123; width: auto; height: auto; &#125;&lt;/style&gt;&lt;div class="wrp wrp6"&gt; &lt;div class="box box6"&gt; &lt;h3&gt;完全居中层6：&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; 【转载】https://segmentfault.com/a/1190000006108996]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS中BFC的详解]]></title>
    <url>%2F2019%2F01%2F23%2FCSS%E4%B8%ADBFC%E7%9A%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CSS中BFC的详解什么是BFC BFC(Block Formatting Context) 格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 形成BFC的条件 浮动元素，float除none 以外的值 定位元素，position(absolue,fixed) display 为以下其中之一的值 inline-block,table-cell,table-caption overflow除了visible以外的值(hidden,auto,scroll) BFC特性 内部的Box会在垂直方向上一个接一个的放置。 BFC内部的Box在垂直方向上一个接一个的放置，即是由上到下的顺序摆放。且是左对齐。 垂直方向上的距离由margin决定。 在正常文档流中，两个兄弟盒子之间的距离（外边距margin）不是相加的距离，而是有最大margin的决定。 bfc的区域不会与float的元素区域重叠。 当前两个盒子有一个是float，有一个是BFC区域的，两个盒子会并排在一个，而不是float在bfc的上面。 计算bfc的高度时，浮动元素也参与计算。 bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。 转载: https://www.cnblogs.com/chen-cong/p/7862832.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next theme添加搜索功能]]></title>
    <url>%2F2018%2F11%2F27%2Fnext-theme%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[next theme配置搜索功能 当博客文章越来越多的时候，逐个查找比较麻烦，搜索功能可以方便的查找。 依赖1npm install hexo-generator-searchdb --save 配置修改 在hexo的配置文件_config.yml添加如下： 12345search: path: search.xml field: post format: html limit: 10000 在next配置文件_config.yml修改如： 12local_search: enable: true]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 2+ 自定义指令]]></title>
    <url>%2F2018%2F07%2F21%2FAngular-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Angular 2+ 指令自定义属性指令 属性指令是改元素的外观、属性、行为的指令，可以指定多个属性指令。 宿主元素：指令所在的元素就是宿主元素。123456&lt;p appHighlight&gt;&lt;/p&gt; //p元素就是宿主元素&lt;app-hero appHighlight&gt;&lt;/app-hero&gt; //app-hero 也是宿主元素&lt;p appHighlight="blue" defaultColor="red" [class.bg]="isBg"&gt; this paragraph is displayed because appHighlight is set to false.&lt;/p&gt; 1234567891011121314151617181920212223242526import &#123; Directive, HostListener, HostBinding, Input, ElementRef &#125; from '@angular/core';@Directive(&#123; selector: '[appHighlight]'&#125;)export class AppHighLightDirective &#123; @Input('appHighlight') highColor = 'yellow'; @Input() defaultColor @HostBinding('class.bg') is:boolean; constructor(private el: ElementRef) &#123;&#125; @HostListener('mouseenter') onMouseEnter () &#123; this.highlight(this.highColor); this.is = true; &#125; @HostListener('mouseleave') onMouseLeave () &#123; this.highlight(this.defaultColor); this.is = false; &#125; private highlight(color: string) &#123; this.el.nativeElement.style.color = color; &#125;&#125; selector 属性选择器，和CSS的选择器类似，但要加上方括号，而组件的选择器不需要方括号。 构造函数 注入的 ElementRef 代表的是宿主元素，由highlight函数也可以看的 出。但是它的属性nativeElement 才真的是可以操作的原生DOM元素。 输入属性 这个和模板语法差不多，一个指令有可能需要外部的数据再做出具体的动作。如上指令，外部给出指定的颜色。根据鼠标移进移出显示不同的外部指定的颜色。 当只有一个输入属性时，可以和指令选择器一样，直接在给指令赋值。但是指令名不能很好的反映该数据时，可以给它一个别名 @Input(&#39;appHighlight&#39;) highColor = &#39;yellow&#39;; 圆括号内的是属性别名。 有多个输入属性时，可以直接在宿主元素里加上该属性名并赋值，然后在指令内部再接收，记得加上@input 修饰符。 这里有一个点是，属性加上方括号时，右边是表达式，不加是字符串。 123&lt;p [appHighlight]="color='blue'" defaultColor="red" [class.bg]="isBg"&gt; this paragraph is displayed because appHighlight is set to false.&lt;/p&gt; @HostBinding 是属性装饰器，用来动态设置宿主元素的属性值。 @HostListener 是属性装饰器，用来为宿主元素添加事件监听。 自定义结构指令 改元素结构的指令，在物理上添加删除指令所在的元素。 123456789101112131415161718192021import &#123; Directive, TemplateRef, ViewContainerRef, Input &#125; from '@angular/core';@Directive(&#123; selector: '[appUnless]'&#125;)export class UnlessDirective &#123; private hasView = false; constructor(private templateRef: TemplateRef&lt;any&gt;, private viewContainerRef: ViewContainerRef) &#123; &#125; @Input() set appUnless(condition: boolean) &#123; if (!condition &amp;&amp; !this.hasView) &#123; this.viewContainerRef.createEmbeddedView(this.templateRef); this.hasView = true; &#125; else if (condition &amp;&amp; this.hasView) &#123; this.viewContainerRef.clear(); this.hasView = false; &#125; &#125; &#125; 123456789&lt;button type="button" (click)="onClick()" class="btn btn-info"&gt;Click&lt;/button&gt;&lt;p *appUnless="condition" class="unless a"&gt; (A) This paragraph is displayed because the condition is false.&lt;/p&gt;&lt;p *appUnless="!condition" class="unless b"&gt; (B) Although the condition is true, this paragraph is displayed because appUnless is set to false.&lt;/p&gt; 结构指令在元素上使用都要加 * 这上语法糖。如 *appUnless 该指令构造函数上有两属性注入。 TemplateRef 该类是一个模板，当前使用结构形指令时，会在当前位置创建一个&lt;ng-template&gt; 并把宿主元素包括所有子元素都包裹其中。对于&lt;ng-template&gt; 元素 Angular不会主动插入到DOM树中。所以在视图上并看不到该模板内容。 ViewContainerRef 是一个视图容器，可以把&lt;ng-template&gt; 模板视图插入其中，这操作需要指令来做。可以插入一个或多个模板内容。插入后在视图上就可以看到该模板内容。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的this的用法]]></title>
    <url>%2F2018%2F06%2F04%2FJavaScript%E7%9A%84this%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaScript的this的用法函数调用 直接调用函数时，不管调用位置如何（函数内或函数外），this都指向全局对象window。 注意：在严格模式下，这种用法是不允许，this返回值是undefined 12345function foo(x)&#123; this.x =x;&#125;foo(2);console.log(x)//2 对象调用 当函数作为对象的方法调用时，函数内的this指向当前调用对象 以下代码中this指向p对象，即当前对象，而不是window 12345678 var n = "true"; var p = &#123; n : "false", m : function()&#123; console.log(this.n); &#125; &#125;p.m()//"false" 构造函数 在构造函数中，this指向新创建的实例对象。 以下代码，函数内部的this指向新创建的对象f 12345function F(x)&#123; this.x = x;&#125;var f = new F(5);console.log(f.x);//5 内部函数 内部函数,相当于直接调用函数所以this指向window 1234567891011var n = "true";var p = &#123; n : "false", m : function()&#123; var say = function()&#123; console.log(this.n); &#125; say(); &#125;&#125;p.m();//true 要使用this指向p对象，代码修改如下 123456789101112var n = "true";var p = &#123; n : "false", m : function()&#123; var that = this; var say = function()&#123; console.log(that.n); &#125; say(); &#125;&#125;p.m();//false]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python定时器实现]]></title>
    <url>%2F2018%2F05%2F13%2FPython-%E6%97%B6%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Python定时器实现时间转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import time, datetimetimes = 2017-12-03 14:27:03 #当前时间 print time.time() # 当前时间戳#1512282423.23struct_time = time.localtime(time.time()) #时间结构化print struct_time #time.struct_time(tm_year=2017, tm_mon=12, tm_mday=3, tm_hour=14, tm_min=27, tm_sec=3, tm_wday=6, tm_yday=337, tm_isdst=0)#tm_wday,当前星期几，0是星期一，tm_isdst 夏令时间， tm_yday当年的第几天strtime = time.strftime('%Y-%m-%d %H:%M:%S', struct_time)print strtime #结构化时间转换成字符串#2017-12-03 14:27:03struct_time = time.strptime(strtime, '%Y-%m-%d %H:%M:%S') #字符串转换成结构化时间print struct_time#time.struct_time(tm_year=2017, tm_mon=12, tm_mday=3, tm_hour=14, tm_min=27, tm_sec=3, tm_wday=6, tm_yday=337, tm_isdst=0)#tm_wday,当前星期几，0是星期一，tm_isdst 夏令时间， tm_yday当年的第几天timestrap = time.mktime(struct_time) #结构化时间转换成时间戳print timestrap#1512282423.0struct_time = time.localtime(timestrap)print struct_timeprint time.strftime('%Y-%m-%d %H:%M:%S', struct_time)struct_time = time.strptime("2017-08-08 12:12", '%Y-%m-%d %H:%M')print struct_time#time.struct_time(tm_year=2017, tm_mon=8, tm_mday=8, tm_hour=12, tm_min=12, tm_sec=0, tm_wday=1, tm_yday=220, tm_isdst=-1)y,m,d,h,M = struct_time[0:5] #获取元组前5个元素print y,m,d,h,M # 2017 8 8 12 12print datetime.datetime(y,m,d,h,M) #2017-08-08 12:12:00datetime.datetime.strptime("2017-08-08 12:12", '%Y-%m-%d %H:%M')#字符转换成datetimenow=datetime.datetime.now() #获取当前时间print now #2017-12-03 14:44:45.056000sched_Timer=datetime.datetime(2017,2,9,20,20,10)print type(sched_Timer) #&lt;type 'datetime.datetime'&gt;print sched_Timer #2017-02-09 20:20:10sched_Timer=sched_Timer + datetime.timedelta(minutes=10)print sched_Timer #2017-02-09 20:30:10#datetime.timedelta(minutes=10) 当前时间加参数里对应的时间，days,hours,minutes,seconds datetime方式12345678910111213141516171819202122import datetimedef run_Task(): print 'hello'def timerFun(sche_timer): flag = 0 while True: now = datetime.datetime.now() if now == sche_timer and flag == 0: run_Task() flag = 1 else: if flag == 1: sche_timer = sche_timer + datetime.timedelta(seconds=5) flag = 0def main(): sche_timer = datetime.datetime(2017, 12, 3, 12, 41, 30) timerFun(sche_timer)if __name__ == '__main__': main() sched方式 schedule这个家伙就像一个预存你要定时执行的任务们儿 的盒子。 schedule.enter就是把你要定时多少秒后执行的任务放到这个盒子里去。而schedule.run就是这时候去run你盒子的所有任务，任务就在这个时刻后，依次相对于这个时刻点的多少秒后运行。如果没有run，那可是不会让盒子的任务被执行。 为什么每一行输出的最后一个时间数据都是一样的（除了最后一行）？因为他们传入函数的数据是当时运行schedule.enter的那个时间点，并非是你定时运行的那个时刻。 而输出中“now is 什么什么”的那个时刻，是运行的func函数中的time.time()，所以代表的是实际运行那个任务的时刻，所以不是一样的。 schedule.enter(delay, priority, action, arguments) 第一个参数是一个整数或者float，代表多少秒后执行这个action任务。 第二个参数priority是优先级，0代表优先级最高，1次之，2次次之…当两个任务是预定在同一个时刻执行时，根据优先级决定谁先执行。 第三个参数就是你要执行的任务，可以简单的理解成你要执行的函数的函数名。 第四个参数是你要传入的这个定时执行的action为函数名的函数的参数，最好是用”()”括号来包起来，包起来肯定是不会出错的。其次，当你只传入一个参数时，用括号包起来后，一定要记住再打上一个逗号。即：schedule.enter(delay, priority, action, (argument1,)) 12345678910111213141516import time, schedschedule = sched.scheduler( time.time, time.sleep)def func(str, flo): print 'now is', time.time(), " | ouput", str, floprint time.time()schedule.enter(2, 0, func, ("test1", time.time()))schedule.enter(2, 0, func, ("test2", time.time()))schedule.enter(3, 0, func, ("test3", time.time()))schedule.enter(4, 0, func, ("test4", time.time()))schedule.run()print time.time() timer时间器 单线程方式 1234567891011121314import time, threadingdef fun_timer(key): print "hello world", key global timer timer = threading.Timer(5.5, fun_timer,('seconds',)) timer.start()"""Call a function after a specified number of seconds"""timer = threading.Timer(1, fun_timer, ("fisrt",))timer.start()time.sleep(12)timer.cancel() 多线程方式 12345678910import timefrom threading import Timerdef print_time( enter_time ): print 'now is', time.time(), 'enter_the_box_time is', enter_timeprint time.time()Timer(5, print_time, (time.time(),)).start()Timer(5, print_time, (time.time(),)).start()print time.time()]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Words!]]></title>
    <url>%2F2018%2F05%2F12%2F%E4%BD%A0%E5%A5%BD%EF%BC%8CHEXO%2F</url>
    <content type="text"><![CDATA[One word One thought Someone is “one tough cookie” if they can handle difficult situations.如果一个人能够处理困难的情况，你就可以说他是“one tough cookie”。 If you describe someone as a tough cookie, you mean that they are unemotional and are not easily hurt by what people say or do.如果你描述一个人是 tough cookie，那么你表示他们是不动情感的，而且不易被别人所说的话所伤害。 She really is a tough cookie.她真正是个铁娘子。 He’s a tough cookie.他是条硬汉子。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Words</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quick Start Hexo]]></title>
    <url>%2F2018%2F05%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
